#!/usr/bin/env bash
set -euo pipefail

script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)
detect_stack_bin="${script_dir}/detect-stack"
repo_root=$(cd "${script_dir}/.." >/dev/null 2>&1 && pwd)
capabilities_adapter="${repo_root}/tools/capabilities_adapter.sh"
capabilities_schema_version=""

usage() {
  cat >&2 <<'USAGE'
Usage: emit-record --run-mode MODE --probe-name NAME --probe-version VERSION \
  --primary-capability-id CAP_ID --command COMMAND \
  --category CATEGORY --verb VERB --target TARGET --status STATUS [options]

Options:
  --errno ERRNO
  --message MESSAGE
  --duration-ms MILLIS
  --raw-exit-code CODE
  --error-detail TEXT
  --secondary-capability-id CAP_ID   # repeat for multiple entries
  --payload-file PATH
  --operation-args JSON_OBJECT
USAGE
  exit 1
}

run_mode=""
probe_id=""
probe_version=""
category=""
verb=""
target=""
status=""
errno_value=""
message=""
duration_ms=""
payload_file=""
operation_args='{}'
primary_capability_id=""
secondary_capability_ids=()
command_executed=""
raw_exit_code=""
error_detail=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --run-mode)
      run_mode="$2"; shift 2 ;;
    --probe-name|--probe-id)
      probe_id="$2"; shift 2 ;;
    --probe-version)
      probe_version="$2"; shift 2 ;;
    --category)
      category="$2"; shift 2 ;;
    --verb)
      verb="$2"; shift 2 ;;
    --target)
      target="$2"; shift 2 ;;
    --status)
      status="$2"; shift 2 ;;
    --errno)
      errno_value="$2"; shift 2 ;;
    --message)
      message="$2"; shift 2 ;;
    --duration-ms)
      duration_ms="$2"; shift 2 ;;
    --raw-exit-code)
      raw_exit_code="$2"; shift 2 ;;
    --error-detail)
      error_detail="$2"; shift 2 ;;
    --payload-file)
      payload_file="$2"; shift 2 ;;
    --operation-args)
      operation_args="$2"; shift 2 ;;
    --primary-capability-id)
      primary_capability_id="$2"; shift 2 ;;
    --secondary-capability-id)
      secondary_capability_ids+=("$2"); shift 2 ;;
    --command)
      command_executed="$2"; shift 2 ;;
    --help|-h)
      usage ;;
    *)
      echo "Unknown flag: $1" >&2
      usage ;;
  esac
done

for var in run_mode probe_id probe_version category verb target status primary_capability_id command_executed; do
  if [[ -z "${!var}" ]]; then
    echo "Missing required flag: --${var//_/-}" >&2
    usage
  fi
done

case "${status}" in
  success|denied|partial|error)
    ;;
  *)
    echo "Unknown status: ${status} (expected success|denied|partial|error)" >&2
    exit 1
    ;;
esac

if [[ ! -x "${detect_stack_bin}" ]]; then
  echo "detect-stack helper not found at ${detect_stack_bin}" >&2
  exit 1
fi

if [[ ! -x "${capabilities_adapter}" ]]; then
  echo "Capability adapter not found or not executable at ${capabilities_adapter}" >&2
  exit 1
fi

capabilities_json=$("${capabilities_adapter}")

known_capability_ids=()
while IFS= read -r cap_line; do
  if [[ -n "${cap_line}" ]]; then
    known_capability_ids+=("${cap_line}")
  fi
done < <(jq -r 'keys[]' <<<"${capabilities_json}")

if [[ ${#known_capability_ids[@]} -eq 0 ]]; then
  echo "No capability IDs returned by ${capabilities_adapter}" >&2
  exit 1
fi

require_capability_id() {
  local value="$1"
  local label="$2"
  local found=1
  for cap in "${known_capability_ids[@]}"; do
    if [[ "${cap}" == "${value}" ]]; then
      found=0
      break
    fi
  done
  if [[ ${found} -ne 0 ]]; then
    echo "Unknown ${label}: ${value}. Expected one of the IDs in spec/capabilities.yaml." >&2
    exit 1
  fi
}

require_capability_id "${primary_capability_id}" "primary capability id"
if [[ ${#secondary_capability_ids[@]} -gt 0 ]]; then
  for sec_cap in "${secondary_capability_ids[@]}"; do
    require_capability_id "${sec_cap}" "secondary capability id"
  done
fi

capabilities_schema_version=$(ruby -I"${repo_root}/tools/lib" -rruby_yaml_loader -e 'data = CodexFence::RubyYamlLoader.safe_load_file(ARGV[0]); puts(data["schema_version"] || "")' "${repo_root}/spec/capabilities.yaml")
if [[ -z "${capabilities_schema_version}" ]]; then
  echo "Unable to determine capabilities schema_version from spec/capabilities.yaml" >&2
  exit 1
fi

capability_snapshot() {
  local cap_id="$1"
  local snapshot
  snapshot=$(jq -c --arg id "${cap_id}" '.[ $id ] // empty | {id, category, platform, layer, status}' <<<"${capabilities_json}")
  if [[ -z "${snapshot}" || "${snapshot}" == "null" ]]; then
    echo "Unable to resolve capability metadata for ${cap_id}" >&2
    exit 1
  fi
  echo "${snapshot}"
}

workspace_root="${FENCE_WORKSPACE_ROOT:-}"
if [[ -z "${workspace_root}" ]]; then
  if repo_root=$(git rev-parse --show-toplevel 2>/dev/null); then
    workspace_root="${repo_root}"
  else
    workspace_root=$(pwd)
  fi
fi

payload_json='{"stdout_snippet": null, "stderr_snippet": null, "raw": {}}'
if [[ -n "${payload_file}" ]]; then
  if [[ ! -f "${payload_file}" ]]; then
    echo "Payload file not found: ${payload_file}" >&2
    exit 1
  fi
  payload_json=$(jq -c '.' "${payload_file}")
fi

operation_args=$(jq -c '.' <<<"${operation_args}")

stack_json=$("${detect_stack_bin}" "${run_mode}")

if [[ ${#secondary_capability_ids[@]} -gt 0 ]]; then
  secondary_caps_json=$(printf '%s\n' "${secondary_capability_ids[@]}" | jq -R -s 'split("\n") | map(select(length > 0)) | unique')
else
  secondary_caps_json='[]'
fi

probe_json=$(jq -n \
  --arg probe_id "${probe_id}" \
  --arg probe_version "${probe_version}" \
  --arg primary_capability_id "${primary_capability_id}" \
  --argjson secondary_capability_ids "${secondary_caps_json}" \
  '{
    id: $probe_id,
    version: $probe_version,
    primary_capability_id: $primary_capability_id,
    secondary_capability_ids: $secondary_capability_ids
  }')

observed_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

run_json=$(jq -n \
  --arg run_mode "${run_mode}" \
  --arg workspace_root "${workspace_root}" \
  --arg command "${command_executed}" \
  --arg observed_at "${observed_at}" \
  '{
    mode: $run_mode,
    workspace_root: (($workspace_root | select(length > 0)) // null),
    command: $command,
    observed_at: $observed_at
  }')

operation_json=$(jq -n \
  --arg category "${category}" \
  --arg verb "${verb}" \
  --arg target "${target}" \
  --argjson args "${operation_args}" \
  '{
    category: $category,
    verb: $verb,
    target: $target,
    args: $args
  }')

result_json=$(jq -n \
  --arg observed_result "${status}" \
  --arg errno_value "${errno_value}" \
  --arg message "${message}" \
  --arg duration_ms "${duration_ms}" \
  --arg raw_exit_code "${raw_exit_code}" \
  --arg error_detail "${error_detail}" \
  '{
    observed_result: $observed_result,
    raw_exit_code: (($raw_exit_code | select(length > 0) | tonumber) // null),
    errno: (($errno_value | select(length > 0)) // null),
    message: (($message | select(length > 0)) // null),
    duration_ms: (($duration_ms | select(length > 0) | tonumber) // null),
    error_detail: (($error_detail | select(length > 0)) // null)
  }')

primary_capability_snapshot=$(capability_snapshot "${primary_capability_id}")

secondary_capability_snapshots='[]'
if [[ ${#secondary_capability_ids[@]} -gt 0 ]]; then
  for sec_cap in "${secondary_capability_ids[@]}"; do
    secondary_capability_snapshots=$(jq -c --argjson current "${secondary_capability_snapshots}" --argjson snapshot "$(capability_snapshot "${sec_cap}")" '($current + [$snapshot]) | unique' <<<"{}")
  done
fi

capability_context=$(jq -n \
  --argjson primary "${primary_capability_snapshot}" \
  --argjson secondary "${secondary_capability_snapshots}" \
  '{ primary: $primary, secondary: $secondary }')

jq -n \
  --arg schema_version "cfbo-v1" \
  --argjson stack "${stack_json}" \
  --argjson probe "${probe_json}" \
  --argjson run "${run_json}" \
  --argjson operation "${operation_json}" \
  --argjson result "${result_json}" \
  --argjson payload "${payload_json}" \
  --argjson capability_context "${capability_context}" \
  --arg capabilities_schema_version "${capabilities_schema_version}" \
  '{
    schema_version: $schema_version,
    capabilities_schema_version: (($capabilities_schema_version | tonumber) // null),
    stack: $stack,
    probe: $probe,
    run: $run,
    operation: $operation,
    result: $result,
    payload: $payload,
    capability_context: $capability_context
  }'

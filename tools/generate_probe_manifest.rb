#!/usr/bin/env ruby
# frozen_string_literal: true

require 'digest'
require 'fileutils'
require 'json'
require 'optparse'
require 'pathname'
require 'time'

class ProbeManifestGenerator
  RUNNER_MARKER_REGEX = /^\s*#\s*probe_runner_api:\s*(\w+)/i
  ASSIGNMENT_REGEX = /^\s*([A-Za-z_][A-Za-z0-9_]*)=(.+)$/

  attr_reader :repo_root, :json_output, :make_output

  def initialize(repo_root:, json_output:, make_output:)
    @repo_root = repo_root
    @json_output = json_output
    @make_output = make_output
  end

  def generate
    probes = probe_files.sort.map { |path| build_entry(path) }
    manifest = {
      'generated_at' => Time.now.utc.iso8601,
      'repo_root' => repo_root,
      'probes' => probes.compact
    }
    write_json(manifest)
    write_makefile(manifest['probes'])
  end

  private

  def probe_files
    Dir.glob(File.join(repo_root, 'probes', '*.sh'))
  end

  def build_entry(path)
    rel_path = Pathname.new(path).relative_path_from(Pathname.new(repo_root)).to_s
    content = File.read(path, encoding: Encoding::UTF_8)
    metadata = parse_metadata(content)
    probe_id = metadata['probe_name'] || File.basename(path, '.sh')
    {
      'id' => probe_id,
      'path' => rel_path,
      'probe_version' => metadata['probe_version'],
      'primary_capability_id' => metadata['primary_capability_id'],
      'runner_api' => metadata['runner_api'] || detect_runner_api(content),
      'sha256' => Digest::SHA256.file(path).hexdigest
    }
  end

  def parse_metadata(content)
    metadata = {}
    content.each_line do |line|
      next unless (match = ASSIGNMENT_REGEX.match(line))
      key = match[1]
      raw_value = match[2]
      value = normalize_value(raw_value)
      metadata[key] = value if value
    end
    metadata
  end

  def normalize_value(raw)
    trimmed = raw.split('#', 2).first.to_s.strip
    return nil if trimmed.empty?
    if (trimmed.start_with?('"') && trimmed.end_with?('"')) ||
       (trimmed.start_with?("'") && trimmed.end_with?("'"))
      trimmed = trimmed[1..-2]
    end
    trimmed
  end

  def detect_runner_api(content)
    content.each_line do |line|
      match = RUNNER_MARKER_REGEX.match(line)
      return match[1].downcase if match
    end
    'legacy'
  end

  def write_json(data)
    return unless json_output
    FileUtils.mkdir_p(File.dirname(json_output))
    File.write(json_output, JSON.pretty_generate(data))
  end

  def write_makefile(probes)
    return unless make_output
    FileUtils.mkdir_p(File.dirname(make_output))
    scripts = probes.map { |p| p['path'] }
    ids = probes.map { |p| p['id'] }
    File.open(make_output, 'w') do |file|
      file.puts('# Autogenerated by tools/generate_probe_manifest.rb')
      file.puts("PROBE_SCRIPTS := #{scripts.join(' ')}")
      file.puts("PROBES := #{ids.join(' ')}")
    end
  end
end

def main
  repo_root = File.expand_path('..', __dir__)
  options = {
    repo_root: repo_root,
    json_output: nil,
    make_output: nil
  }

  parser = OptionParser.new do |opts|
    opts.banner = 'Usage: generate_probe_manifest.rb --json <file> --make <file>'
    opts.on('--json PATH', 'Path to write JSON manifest') { |v| options[:json_output] = v }
    opts.on('--make PATH', 'Path to write Makefile fragment') { |v| options[:make_output] = v }
    opts.on('--repo-root PATH', 'Override repository root') { |v| options[:repo_root] = File.expand_path(v) }
  end
  parser.parse!

  if !options[:json_output] && !options[:make_output]
    warn 'generate_probe_manifest: at least one of --json or --make must be provided'
    exit 1
  end

  generator = ProbeManifestGenerator.new(
    repo_root: options[:repo_root],
    json_output: options[:json_output],
    make_output: options[:make_output]
  )
  generator.generate
end

main if $PROGRAM_NAME == __FILE__

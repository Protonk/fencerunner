#!/usr/bin/env ruby
# frozen_string_literal: true

require 'english'
require 'json'
require 'optparse'
require 'open3'
require 'pathname'
require 'shellwords'
require 'tempfile'
require 'time'

module ProbeRunner
  class Error < StandardError; end

  Probe = Struct.new(
    :id,
    :path,
    :probe_version,
    :primary_capability_id,
    :runner_api,
    keyword_init: true
  )

  class Manifest
    def initialize(entries)
      @entries = entries
      @by_id = entries.each_with_object({}) { |entry, memo| memo[entry.id] = entry }
      @by_path = entries.each_with_object({}) { |entry, memo| memo[entry.path] = entry }
    end

    def self.load(path)
      data = JSON.parse(File.read(path))
      entries = Array(data['probes']).map do |probe|
        Probe.new(
          id: probe['id'],
          path: probe['path'],
          probe_version: probe['probe_version'],
          primary_capability_id: probe['primary_capability_id'],
          runner_api: probe['runner_api'] || 'legacy'
        )
      end
      new(entries)
    end

    def fetch_by_id(id)
      @by_id.fetch(id) { raise Error, "probe '#{id}' not found in manifest" }
    end

    def find_by_path(path)
      @by_path[path]
    end
  end

  class MetadataExtractor
    ASSIGNMENT = /^\s*([A-Za-z_][A-Za-z0-9_]*)=(.+)$/.freeze
    RUNNER_MARKER = /^\s*#\s*probe_runner_api:\s*(\w+)/i.freeze

    def self.extract(path, repo_root)
      absolute = File.expand_path(path)
      rel_path = Pathname.new(absolute).relative_path_from(Pathname.new(repo_root)).to_s
      content = File.read(absolute)
      metadata = {
        'id' => File.basename(path, '.sh'),
        'path' => rel_path,
        'runner_api' => 'legacy'
      }

      content.each_line do |line|
        if (match = ASSIGNMENT.match(line))
          key = match[1]
          value = normalize(match[2])
          metadata[key] = value if value
        elsif (marker = RUNNER_MARKER.match(line))
          metadata['runner_api'] = marker[1].downcase
        end
      end

        ProbeRunner::Probe.new(
          id: metadata['probe_name'] || metadata['id'],
          path: rel_path,
          probe_version: metadata['probe_version'],
          primary_capability_id: metadata['primary_capability_id'],
          runner_api: metadata['runner_api'] || 'legacy'
        )
    end

    def self.normalize(value)
      raw = value.split('#', 2).first.to_s.strip
      return nil if raw.empty?
      if (raw.start_with?('"') && raw.end_with?('"')) ||
         (raw.start_with?("'") && raw.end_with?("'"))
        raw = raw[1..-2]
      end
      raw
    end
  end

  class BaseExecutor
    attr_reader :probe, :repo_root, :mode

    def initialize(probe:, repo_root:, mode:)
      @probe = probe
      @repo_root = repo_root
      @mode = mode
    end

    def env
      {
        'FENCE_RUN_MODE' => mode,
        'FENCE_WORKSPACE_ROOT' => repo_root
      }
    end

    def emit_record_bin
      File.join(repo_root, 'bin', 'emit-record')
    end
  end

  class LegacyExecutor < BaseExecutor
    def run
      script_path = absolute_probe_path
      unless File.exist?(script_path)
        raise Error, "legacy probe script not found at #{script_path}"
      end
      Dir.chdir(repo_root) do
        system(env, script_path)
        raise Error, "legacy probe #{probe.id} failed" unless $CHILD_STATUS.success?
      end
    end

    private

    def absolute_probe_path
      if Pathname.new(probe.path).absolute?
        probe.path
      else
        File.join(repo_root, probe.path)
      end
    end
  end

  class ModuleExecutor < BaseExecutor
    RESULT_FILE_ENV = 'PROBE_RUNNER_RESULT_FILE'

    def run
      ensure_metadata!
      Dir.chdir(repo_root) do
        Tempfile.create('probe-runner-result') do |result_file|
          run_module_script(result_file.path)
          data = JSON.parse(File.read(result_file.path))
          emit_record(data)
        end
      end
    end

    private

    def ensure_metadata!
      if probe.primary_capability_id.to_s.empty?
        raise Error, "probe #{probe.id} is missing primary_capability_id"
      end
      if probe.probe_version.to_s.empty?
        raise Error, "probe #{probe.id} is missing probe_version"
      end
    end

    def module_helper
      File.join(repo_root, 'tools', 'lib', 'probe_runner_module.sh')
    end

    def script_path
      File.absolute_path(probe.path, repo_root)
    end

    def run_module_script(result_path)
      command = <<~BASH
        set -euo pipefail
        source #{Shellwords.escape(module_helper)}
        source #{Shellwords.escape(script_path)}
        probe_runner_main
      BASH
      env_vars = env.merge(RESULT_FILE_ENV => result_path)
      stdout_str, stderr_str, status = Open3.capture3(env_vars, '/bin/bash', '-c', command)
      $stdout.print(stdout_str) unless stdout_str.empty?
      unless status.success?
        warn(stderr_str) unless stderr_str.empty?
        raise Error, "module probe #{probe.id} failed"
      end
    end

    def emit_record(data)
      payload_file = data['payload_file']
      operation_args = data['operation_args'] || {}
      args = [
        emit_record_bin,
        '--run-mode', mode,
        '--probe-name', probe.id,
        '--probe-version', probe.probe_version,
        '--primary-capability-id', probe.primary_capability_id,
        '--command', data.fetch('command'),
        '--category', data.fetch('category'),
        '--verb', data.fetch('verb'),
        '--target', data.fetch('target'),
        '--status', data.fetch('status')
      ]
      append_optional(args, '--raw-exit-code', data['raw_exit_code'])
      append_optional(args, '--errno', data['errno'])
      append_optional(args, '--message', data['message'])
      append_optional(args, '--duration-ms', data['duration_ms'])
      append_optional(args, '--error-detail', data['error_detail'])
      if payload_file.to_s.empty?
        raise Error, "probe #{probe.id} did not provide payload_file"
      end
      args += ['--payload-file', File.expand_path(payload_file, repo_root)]
      args += ['--operation-args', JSON.generate(operation_args)]

      env_vars = env
      system(env_vars, *args)
      raise Error, "emit-record failed for probe #{probe.id}" unless $CHILD_STATUS.success?
    end

    def append_optional(args, flag, value)
      args.push(flag, value.to_s) unless value.nil? || value == ''
    end
  end
end

def main
  repo_root = File.expand_path('..', __dir__)
  options = {
    mode: ENV.fetch('FENCE_RUN_MODE', 'baseline'),
    manifest: File.join(repo_root, 'tmp', 'probes_manifest.json'),
    probes: [],
    script: nil
  }

  parser = OptionParser.new do |opts|
    opts.banner = 'Usage: bin/probe-runner [options]'
    opts.on('--mode MODE', 'Run mode (baseline, codex-sandbox, codex-full)') { |v| options[:mode] = v }
    opts.on('--manifest PATH', 'Path to manifest JSON (default tmp/probes_manifest.json)') { |v| options[:manifest] = v }
    opts.on('--probe ID', 'Probe id from manifest (repeatable)') { |v| options[:probes] << v }
    opts.on('--script PATH', 'Run a standalone probe script (bypasses manifest)') { |v| options[:script] = v }
    opts.on('-h', '--help', 'Show help') do
      puts opts
      exit 0
    end
  end
  parser.parse!

  if options[:script] && !options[:probes].empty?
    warn 'probe-runner: --script cannot be combined with --probe'
    exit 1
  end

  entries =
    if options[:script]
      [ProbeRunner::MetadataExtractor.extract(options[:script], repo_root)]
    else
      if options[:probes].empty?
        warn 'probe-runner: specify at least one --probe or use --script'
        exit 1
      end
      manifest = ProbeRunner::Manifest.load(options[:manifest])
      options[:probes].map { |id| manifest.fetch_by_id(id) }
    end

  entries.each do |entry|
    executor =
      if entry.runner_api == 'module'
        ProbeRunner::ModuleExecutor.new(probe: entry, repo_root: repo_root, mode: options[:mode])
      else
        ProbeRunner::LegacyExecutor.new(probe: entry, repo_root: repo_root, mode: options[:mode])
      end
    executor.run
  end
end

begin
  main
rescue ProbeRunner::Error => e
  warn("probe-runner: #{e.message}")
  exit 1
end
